extern crate proc_macro;
extern crate proc_macro2;
#[macro_use]
extern crate quote;

use proc_macro::TokenStream;
use proc_macro2::Span;

/// This module contains the implementation of a derive macro for the `TSerializable` trait
/// The generated code might not be optimal but fits to the code generated by the thrift compiler
/// in its current version

/// Checks if a field type is an option type. Only works for Option<T>.
/// Fails to check std::option::Option patterns.
/// We don't need more sofisticated check since we control the way field are declared
/// inside Thrift structs.
fn type_is_option(field_type: &syn::Type) -> bool {
    if let syn::Type::Path(field_type) = field_type {
        let path = &field_type.path;
        path.leading_colon.is_none()
            && path.segments.len() == 1
            && path.segments.iter().next().unwrap().ident == "Option"
    } else {
        false
    }
}

/// Checks it a DataEnum represents a thrift enum or a thrift union
fn data_enum_is_union(data_enum: &syn::DataEnum) -> bool {
    if let Some(first_variant) = data_enum.variants.first() {
        if first_variant.discriminant.is_none() {
            return true;
        }
    }
    return false;
}

/// Generates the get_ttype method of the TSerializable trait
fn generate_get_ttype(ast: &syn::DeriveInput) -> proc_macro2::TokenStream {
    let content = match &ast.data {
        syn::Data::Enum(data_enum) => {
            if data_enum_is_union(data_enum) {
                quote! { TType::Struct }
            } else {
                quote! { TType::I32 }
            }
        }
        syn::Data::Struct(_) => quote! { TType::Struct },
        syn::Data::Union(_) => panic!("Can't derive TSerialize for Union types"),
    };
    quote! {
        fn get_ttype() -> TType {
            #content
        }
    }
}

/// Generates the first part of the read_from_in_protocol method for structs (variables declaration and
/// read_struct_begin call)
/// The declared variables are all of type Option<T>, even if the corresponding field is not of
/// option type. In that case, the variables are check in the footer of the method (see
/// `generate_read_from_footer` method)
fn generate_read_from_header_struct(fields: &syn::Fields) -> proc_macro2::TokenStream {
    let mut tokens: Vec<proc_macro2::TokenStream> = Vec::new();
    for (index, field) in fields.into_iter().enumerate() {
        let field_type = &field.ty;
        let shifted_index = index + 1;
        let tmp_ident = format_ident!("f_{}", shifted_index);
        if type_is_option(field_type) {
            tokens.push(quote! {
                let mut #tmp_ident : #field_type = None;
            });
        } else {
            tokens.push(quote! {
                let mut #tmp_ident : Option<#field_type> = None;
            });
        }
    }
    quote! {
        i_prot.read_struct_begin()?;
        #( #tokens)*
    }
}

/// Generates the main loop of the read_from_in_protocol method of the TSerialiable trait for
/// structs
/// The loop consists in reading an incoming value identifier and matching its value against
/// all the possible fields index.
fn generate_read_from_loop_struct(fields: &syn::Fields) -> proc_macro2::TokenStream {
    let mut tokens: Vec<proc_macro2::TokenStream> = Vec::new();
    for (index, field) in fields.into_iter().enumerate() {
        let field_type = &field.ty;
        let shifted_index = syn::Index::from(index + 1);
        let tmp_ident = format_ident!("f_{}", index + 1);
        if type_is_option(field_type) {
            tokens.push(quote! {
                #shifted_index => #tmp_ident = *<#field_type>::read_from_in_protocol(i_prot)?,
            });
        } else {
            tokens.push(quote! {
                #shifted_index => #tmp_ident = Some(*<#field_type>::read_from_in_protocol(i_prot)?),
            });
        }
    }
    quote! {
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                  break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                #( #tokens )*
                _ => i_prot.skip(field_ident.field_type)?
            }
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
    }
}

/// Generates the main loop of the read_from_in_protocol method of the TSerialiable trait for enums
/// representing thrift union types.
fn generate_read_from_loop_union(
    enum_name: &syn::Ident,
    data_enum: &syn::DataEnum,
) -> proc_macro2::TokenStream {
    let mut tokens: Vec<proc_macro2::TokenStream> = Vec::new();
    for (index, variant) in data_enum.variants.iter().enumerate() {
        let shifted_index = syn::Index::from(index + 1);
        let variant_name = &variant.ident;
        let field = variant.fields.iter().next().unwrap();
        let variant_field_type = &field.ty;
        tokens.push(quote! {
            #shifted_index => {
                let val = <#variant_field_type>::read_from_in_protocol(i_prot)?;
                if ret.is_none() {
                    ret = Some(#enum_name::#variant_name(*val));
                }
                received_field_count += 1;
            }
        });
    }
    quote! {
        loop {
            let field_ident = i_prot.read_field_begin()?;
            if field_ident.field_type == TType::Stop {
                  break;
            }
            let field_id = field_id(&field_ident)?;
            match field_id {
                #( #tokens )*
                _ => {
                    i_prot.skip(field_ident.field_type)?;
                    received_field_count += 1;
                },
            };
            i_prot.read_field_end()?;
        }
        i_prot.read_struct_end()?;
    }
}

/// Generates the end of the read_from_in_protocol method of the TSerializable trait for structs
/// The generated piece of code builds an instance of the struct using the values read in the main
/// loop and returns it.
fn generate_read_from_footer_struct(
    struct_name: &syn::Ident,
    fields: &syn::Fields,
) -> proc_macro2::TokenStream {
    let mut field_tokens: Vec<proc_macro2::TokenStream> = Vec::new();
    let mut verif_tokens: Vec<proc_macro2::TokenStream> = Vec::new();
    for (index, field) in fields.into_iter().enumerate() {
        let field_name = &field.ident;
        let tmp_ident = format_ident!("f_{}", index + 1);
        let field_type = &field.ty;
        if type_is_option(field_type) {
            field_tokens.push(quote! {
                #field_name: #tmp_ident
            });
        } else {
            field_tokens.push(quote! {
                #field_name: #tmp_ident.expect("auto-generated code should have check for presence of required fields")
            });
            verif_tokens.push(quote! {
                verify_required_field_exists(
                    &format!("{}.{}", stringify!(#struct_name), stringify!(#field_name)),
                    &#tmp_ident)?
            });
        }
    }
    quote! {
        #( #verif_tokens );*;
        let res = #struct_name {
            #( #field_tokens ),*
        };
        thrift::Result::Ok(Box::new(res))
    }
}

/// Generates the end of the read_from_in_protocol method of the TSerializable trait for enum
/// representing thrift unions
/// The generated piece of code builds an instance of the struct using the values read in the main
/// loop and returns it.
fn generate_read_from_footer_union(enum_name: &syn::Ident) -> proc_macro2::TokenStream {
    quote! {
        if received_field_count == 0 {
            Err(
                thrift::Error::Protocol(
                    ProtocolError::new(
                        ProtocolErrorKind::InvalidData,
                        format!("received empty union from remote {}", stringify!(#enum_name))
                    )
                )
            )
        } else if received_field_count > 1 {
            Err(
                thrift::Error::Protocol(
                    ProtocolError::new(
                        ProtocolErrorKind::InvalidData,
                        format!("received multiple fields for union from remote {}", stringify!(#enum_name))
                    )
                )
            )
        } else {
            Ok(ret.map(Box::new).expect("return value should have been constructed"))
        }
    }
}

/// Generates the implentation of the `read_from_in_protocol` method of the TSerializable trait
fn generate_read_from(ast: &syn::DeriveInput) -> proc_macro2::TokenStream {
    match &ast.data {
        syn::Data::Struct(val) => {
            let read_from_header = generate_read_from_header_struct(&val.fields);
            let read_from_loop = generate_read_from_loop_struct(&val.fields);
            let read_from_footer = generate_read_from_footer_struct(&ast.ident, &val.fields);
            quote! {
                fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Box<Self>> {
                    #read_from_header
                    #read_from_loop
                    #read_from_footer
                }
            }
        }
        syn::Data::Enum(data_enum) => {
            if data_enum_is_union(data_enum) {
                let union_name = &ast.ident;
                let read_from_loop = generate_read_from_loop_union(&ast.ident, data_enum);
                let read_from_footer = generate_read_from_footer_union(&ast.ident);
                //let mut ret = Option<#union_name> = None;
                quote! {
                    fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Box<Self>> {
                        let mut ret: Option<#union_name> = None;
                        let mut received_field_count = 0;
                        i_prot.read_struct_begin()?;
                        #read_from_loop
                        #read_from_footer
                    }
                }
            } else {
                let enum_ident = &ast.ident;
                quote! {
                    fn read_from_in_protocol(i_prot: &mut dyn TInputProtocol) -> thrift::Result<Box<Self>> {
                        let enum_value = i_prot.read_i32()?;
                        #enum_ident::try_from(enum_value).map(|v| Box::new(v))
                    }
                }
            }
        }
        _ => panic!("Can't derive TSerializable for union types"),
    }
}

/// Generates the body of the write_to_out_protocol method
/// Each field is written sequentially
/// Two cases:
/// * if the field type is an Option, the value is checked and the field is simply skipped if None
///   In that case, we have a guarantee that the underlying type implements the TSerializable
///   trait, so we can safely write the inner value in the
/// * if the field is not an Option (e.g in the case of XXX_args/_result objects)
fn generate_write_to_body(fields: &syn::Fields) -> proc_macro2::TokenStream {
    let mut tokens: Vec<proc_macro2::TokenStream> = Vec::new();
    for (index, field) in fields.into_iter().enumerate() {
        let field_type = &field.ty;
        let shifted_index = syn::Index::from(index + 1);
        let self_ident = syn::Ident::new("self", Span::call_site());
        let simple_ident = &field.ident;
        if type_is_option(field_type) {
            tokens.push(quote!{
                if let Some(ref inner) = #self_ident.#simple_ident {
                    o_prot.write_field_begin(
                        &TFieldIdentifier::new(stringify!(#simple_ident), <#field_type>::get_ttype(), #shifted_index))?;
                    inner.write_to_out_protocol(o_prot)?;
                    o_prot.write_field_end()?;
                }
            });
        } else {
            tokens.push(quote! {
                o_prot.write_field_begin(
                    &TFieldIdentifier::new(
                        stringify!(#simple_ident),
                        <#field_type>::get_ttype(),
                        #shifted_index
                    )
                )?;
                #self_ident.#simple_ident.write_to_out_protocol(o_prot)?;
                o_prot.write_field_end()?;
            });
        }
    }
    quote! {
        #( #tokens )*
    }
}

/// Generates the `write_to_out_protocol` method of the TSerializable trait for thrift enums
fn generate_write_to_enum() -> proc_macro2::TokenStream {
    quote! {
        fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()>{
            o_prot.write_i32(*self as i32)
        }
    }
}

/// Generates the `write_to_out_protocol` method of the TSerializable trait for thrift unions
fn generate_write_to_union_body(
    union_name: &syn::Ident,
    variants: &syn::punctuated::Punctuated<syn::Variant, syn::token::Comma>,
) -> proc_macro2::TokenStream {
    let mut tokens: Vec<proc_macro2::TokenStream> = Vec::new();
    for (index, variant) in variants.iter().enumerate() {
        let variant_name = &variant.ident;
        let shifted_index = syn::Index::from(index + 1);
        let field = variant.fields.iter().next().unwrap();
        let field_type = &field.ty;
        tokens.push(quote! {
            #union_name::#variant_name(ref f) => {
                o_prot.write_field_begin(
                    &TFieldIdentifier::new(
                        stringify!(#variant_name).to_lowercase(),
                        <#field_type>::get_ttype(),
                        #shifted_index
                    )
                )?;
                f.write_to_out_protocol(o_prot)?;
                o_prot.write_field_end()?;
            },
        });
    }
    quote! { #(  #tokens )*
    }
}

/// Generates the `write_to` method of the TSerializable trait
fn generate_write_to(ast: &syn::DeriveInput) -> proc_macro2::TokenStream {
    match &ast.data {
        syn::Data::Enum(data_enum) => {
            if data_enum_is_union(data_enum) {
                let body_tokens = generate_write_to_union_body(&ast.ident, &data_enum.variants);
                return quote! {
                    fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()>{
                        let struct_ident = TStructIdentifier::new(Self::get_thrift_name());
                        o_prot.write_struct_begin(&struct_ident)?;
                        match *self {
                            #body_tokens
                        }
                        o_prot.write_field_stop()?;
                        o_prot.write_struct_end()
                    }
                };
            } else {
                return generate_write_to_enum();
            }
        }
        syn::Data::Struct(val) => {
            let fields = &val.fields;
            let body_tokens = generate_write_to_body(fields);
            quote! {
                fn write_to_out_protocol(&self, o_prot: &mut dyn TOutputProtocol) -> thrift::Result<()>{
                    let struct_ident = TStructIdentifier::new(Self::get_thrift_name());
                    o_prot.write_struct_begin(&struct_ident)?;
                    #body_tokens
                    o_prot.write_field_stop()?;
                    o_prot.write_struct_end()
                }
            }
        }
        _ => panic!("Cannot implement TSerializable for union types!"),
    }
}

/// The main method generating the implementation of the TSerializable trait
fn impl_tserialize(ast: &syn::DeriveInput) -> TokenStream {
    let ident = &ast.ident;
    let get_ttype_tokens = generate_get_ttype(ast);
    let read_from_tokens = generate_read_from(ast);
    let write_to_tokens = generate_write_to(ast);
    (quote! {
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl TSerializable for #ident {
            #get_ttype_tokens
            #read_from_tokens
            #write_to_tokens
        }
    })
    .into()
}
/// A derive macro for the `TSerializable` trait
#[proc_macro_derive(TSerializable)]
pub fn tserialize(input: TokenStream) -> TokenStream {
    impl_tserialize(&syn::parse(input).expect("Parse derive input failed."))
}
